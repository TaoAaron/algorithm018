# 学习笔记

## Hash table 哈希表

&emsp;哈希表(Hash table)，也叫散列表，是根据关键码值(key value)而直接进行访问的数据结构.  

&emsp;它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫作散列函数(Hash Function)，存放记录的数组叫作哈希表(或散列表). 

&emsp;散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

&emsp;散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

&emsp;散列函数，顾名思义，它是一个函数。我们可以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。  

### 散列函数设计的基本要求:  
&emsp; 散列函数计算得到的散列值是一个非负整数;  
&emsp; 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。  
&emsp;如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。


&emsp;第三点实现起来很困难，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。  

散列冲突的解决方法：开放寻址法（open addressing）和链表法（chaining）。

### 开放寻址法  
&emsp;二次探测（Quadratic probing）  
&emsp;双重散列（Double hashing）  
&emsp;不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。  
&emsp;散列表的装载因子=填入表中的元素个数/散列表的长度装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。  

### 链表法
&emsp; 在哈希冲突的位置拉出一个链表，拉链式解决。

# 树、二叉树、图

二叉树遍历  
&emsp; 1、前序(Pre-order)：根-左-右  
&emsp; 2、中序(In-order)：左-根-右  
&emsp; 3、后序(Post-order)：左-右-根  

&emsp; 问什么用递归实现树的遍历？代码简洁，逻辑明了  

## 二叉搜索树 Binary Search Tree
&emsp; 二叉搜索树，也称二叉排序树、有序二叉树(Ordered Binary Tree)、排序二叉树(Sorted Binary Tree)，是指一棵空树或者具有下列性质的二叉树：  
&emsp; 	1、左子树上的所有结点的值均小于它的根结点的值;  
&emsp; 	2、右子树上的所有结点的值均大于它的根结点的值；  
&emsp; 	3、依次类推：左、右子树也分别为二叉查找树。  

中序遍历：升序排列  
	
### 二叉搜索树常见的操作：
&emsp; 1、查询  (log2n)  
&emsp; 2、插入新结点(创建)   
&emsp; 3、删除  
删除的是叶子结点 — 直接删除就行    
删除的是关键结点 —  选择小于它的最大的结点、选择大于它的最小的结点    
	

# 堆
堆Heap：可以迅速找到一堆数中的最大或者最小值的数据结构。  
&emsp;将根结点最大的堆叫做大顶堆或大根堆，根结点最小的堆叫做小顶堆或小根堆。 常见的堆有二叉堆、斐波那契堆。

假设是大顶堆，常见操作(API)：  
&emsp;find-max：O(1)  
&emsp;delete-max：O(logN)  
&emsp;insert(create)：O(logN)orO(1)  

### 二叉堆性质
通过完全二叉树来实现(不是二叉搜索树)；  
&emsp;[性质一]是一课完全树。  
&emsp;[性质二]树中任意节点的值总是>=其子节点的值。  

### 为什么不能用二叉搜索树来实现呢？
二叉搜索树需要找到最大或最小值需要查找，其时间复杂度是logN的，而最大/小堆，find-max/find-min是O(1)的。  

注意：二叉堆是堆(优先队列 priority_queue)的一种常见且简单的实现；但并不是最优的实现。


