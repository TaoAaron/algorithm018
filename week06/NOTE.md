# 动态规划  
### 本质：寻找重复性  

递归状态树、重复子状态  

Dynamic Programming

2、Simplifying a complicated problem by breaking it down into   
simpler sub-problems

3、Divide & Conquer + Optimal substructure  
	分治 + 最优子结构  

动态规划 和 递归或者分治 没有根本上的区别(关键看有无最优的子结构)  

&emsp;共性：找到重复子问题
&emsp;差异性：最优子结构、中途可以淘汰次优解

## 动态规划关键点：
1、最优子结构 opt[n] = best_of(opt[n-1],opt[n-2], …)  
2、存储中间状态：opt[i]  
3、递推公式(状态转移方程或者DP方程)  
	Fib：opt[i] = opt[n-1] + opt[n-2]  

## 动态规划的三个特征  
### 最优子结构  
最优子结构指的是，问题的最优解包含子问题的最优解。即我们可以通过子问题  
的最优解推导出问题的最优解。把最优子结构对应到动态规划问题模型上，就可  
以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。  
### 无后效性  
无后效性的两层含义：第一层含义是，在推导后面阶段的状态的时候，只关心前  
面的状态值，不关心这个状态是怎么一步一步推导出来的。  
第二层含义是，某阶段的状态一旦确定，就不受之后阶段的决策影响。无后效性  
是一个非常“宽松”的要求。只要满足了动态规划问题模型就行。  
### 重复字问题  
不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。  

## 解决动态规划的思路  
### 状态转移表法  
一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，  
当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，  
每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可  
以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻  
找规律，看是否能用动态规划解决。  
找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用回溯  
加“备忘录”的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划  
的解决思路没有差别。第二种是使用动态规划的解决方法，状态转移表法。  
总结：回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态  
转移表 - 根据递推关系填表 - 将填表过程翻译成代码。状态
### 状态转移方程  
状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通  
过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递  
归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常  
简单了。一般情况下，我们有两种代码实现方法，一种是递归加“备忘录”，  
另一种是迭代递推。  
找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。  
 



